<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Chinese Homophonic Cipher</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0f172a;
            color: #f1f5f9;
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #1e293b;
            border-radius: 10px;
            border: 1px solid #334155;
        }

        .panel {
            background: #1e293b;
            padding: 25px;
            border-radius: 10px;
            border: 1px solid #334155;
            margin-bottom: 20px;
        }

        .panel-title {
            font-size: 1.4rem;
            font-weight: bold;
            color: #60a5fa;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #94a3b8;
            font-size: 0.9rem;
        }

        input, textarea, select {
            width: 100%;
            padding: 12px;
            background: #334155;
            border: 1px solid #475569;
            border-radius: 6px;
            color: #f1f5f9;
            font-size: 1rem;
            font-family: inherit;
        }

        textarea {
            min-height: 100px;
            resize: vertical;
        }

        .btn {
            padding: 12px 24px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-family: inherit;
        }

        .btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        .btn-primary {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }

        .output-box {
            background: #334155;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #475569;
            margin-top: 10px;
            min-height: 60px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .status {
            padding: 12px;
            border-radius: 6px;
            margin: 15px 0;
            font-weight: 600;
        }

        .status-info {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid #3b82f6;
            color: #3b82f6;
        }

        .status-success {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid #10b981;
            color: #10b981;
        }

        .status-error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid #ef4444;
            color: #ef4444;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: #334155;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #60a5fa;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #94a3b8;
            margin-top: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #334155;
            border-radius: 3px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            transition: width 0.3s;
        }

        .code-block {
            background: #0f172a;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #334155;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            margin: 10px 0;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîê Chinese Homophonic Cipher System</h1>
            <p>Professional Implementation - 1000 Characters ‚Üí 1,000,000 Homophones</p>
        </div>

        <div class="panel">
            <div class="panel-title">‚öôÔ∏è SYSTEM INITIALIZATION</div>
            
            <div class="input-group">
                <label>ENCRYPTION KEY</label>
                <input type="password" id="encryptionKey" value="quantum-secure-key-2024">
            </div>

            <div class="input-group">
                <label>CHARACTER SET SIZE</label>
                <select id="characterSet">
                    <option value="1000">1000 Characters (1,000,000 homophones)</option>
                    <option value="500">500 Characters (250,000 homophones)</option>
                    <option value="256">256 Characters (65,536 homophones)</option>
                </select>
            </div>

            <button class="btn btn-primary" onclick="initializeCipherSystem()">
                üöÄ INITIALIZE CIPHER SYSTEM
            </button>

            <div class="progress-bar">
                <div class="progress-fill" id="initProgress"></div>
            </div>

            <div id="systemStatus" class="status status-info">
                ‚óè SYSTEM READY FOR INITIALIZATION
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="totalHomophones">0</div>
                    <div class="stat-label">TOTAL HOMOPHONES</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="homophonesPerCell">0</div>
                    <div class="stat-label">HOMOPHONES/CELL</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="sboxSize">65,536</div>
                    <div class="stat-label">S-BOX CELLS</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="characterCount">0</div>
                    <div class="stat-label">CHARACTERS USED</div>
                </div>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">üîí ENCRYPTION</div>
            
            <div class="input-group">
                <label>PLAINTEXT (Any Language)</label>
                <textarea id="plaintext">Top secret message! Confidential data 2024.</textarea>
            </div>

            <div class="input-group">
                <label>RANDOMNESS MODE</label>
                <select id="randomnessMode">
                    <option value="crypto">Cryptographically Secure (CSPRNG)</option>
                    <option value="deterministic">Deterministic (Testing)</option>
                </select>
            </div>

            <button class="btn btn-success" onclick="encryptMessage()">
                üîí ENCRYPT MESSAGE
            </button>

            <div class="input-group">
                <label>CIPHERTEXT OUTPUT</label>
                <div class="output-box" id="ciphertextOutput"></div>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">üîì DECRYPTION</div>
            
            <div class="input-group">
                <label>CHINESE CIPHERTEXT INPUT</label>
                <textarea id="ciphertextInput"></textarea>
            </div>

            <button class="btn btn-primary" onclick="decryptMessage()">
                üîì DECRYPT MESSAGE
            </button>

            <div class="input-group">
                <label>DECRYPTED PLAINTEXT</label>
                <div class="output-box" id="decryptedOutput"></div>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">üìä SYSTEM INFORMATION</div>
            
            <div class="code-block">
// ALGORITHM: Homophonic Substitution Cipher
// MAPPING: 2 bytes ‚Üí 2 Chinese characters
// S-BOX: 65,536 cells (256√ó256 grid)
// HOMOPHONES: 1,000,000 unique pairs
// SECURITY: Key-dependent S-box generation
// ENTROPY: ~15 bits per Chinese character pair
            </div>

            <div class="input-group">
                <label>PERFORMANCE METRICS</label>
                <div class="output-box" id="performanceMetrics">
                    System metrics will appear here after initialization...
                </div>
            </div>

            <button class="btn" onclick="runDiagnostics()">
                ü©∫ RUN SYSTEM DIAGNOSTICS
            </button>
        </div>
    </div>

    <script>
        class ProfessionalChineseCipher {
            constructor() {
                this.sBox = new Map();
                this.reverseMap = new Map();
                this.initialized = false;
                this.metrics = {
                    initializationTime: 0,
                    encryptionSpeed: 0,
                    decryptionSpeed: 0,
                    entropy: 0
                };
            }

            async initializeSystem(encryptionKey, characterCount = 1000, progressCallback = null) {
                const startTime = performance.now();
                
                this.sBox.clear();
                this.reverseMap.clear();
                this.initialized = false;

                // Generate professional character set
                const characters = this.generateCharacterSet(characterCount);
                const totalPairs = characterCount * characterCount;
                const totalCells = 65536; // 256√ó256 S-Box

                if (progressCallback) progressCallback(10, "Generating homophone pairs...");

                // Create all possible homophone pairs
                const allHomophones = [];
                for (let i = 0; i < characterCount; i++) {
                    for (let j = 0; j < characterCount; j++) {
                        allHomophones.push(characters[i] + characters[j]);
                    }
                    if (progressCallback && i % 100 === 0) {
                        progressCallback(10 + (i / characterCount) * 30, 
                            `Generated ${(i * characterCount).toLocaleString()}/${totalPairs.toLocaleString()} pairs`);
                    }
                }

                if (progressCallback) progressCallback(40, "Cryptographic shuffling...");

                // Professional key-based shuffling
                const shuffledHomophones = await this.cryptographicShuffle(allHomophones, encryptionKey);

                if (progressCallback) progressCallback(70, "Building S-Box structure...");

                // Perfect distribution calculation
                const baseHomophonesPerCell = Math.floor(totalPairs / totalCells);
                const extraHomophones = totalPairs % totalCells;

                let homophoneIndex = 0;
                let distributedCount = 0;

                // Build 256√ó256 S-Box
                for (let row = 0; row < 256; row++) {
                    for (let col = 0; col < 256; col++) {
                        const cellValue = (row << 8) | col;
                        const homophoneCount = (row * 256 + col) < extraHomophones ? 
                            baseHomophonesPerCell + 1 : baseHomophonesPerCell;

                        const cellHomophones = shuffledHomophones.slice(
                            homophoneIndex, 
                            homophoneIndex + homophoneCount
                        );
                        
                        homophoneIndex += homophoneCount;
                        distributedCount += homophoneCount;

                        this.sBox.set(cellValue, cellHomophones);

                        // Build reverse mapping for fast decryption
                        for (const homophone of cellHomophones) {
                            this.reverseMap.set(homophone, cellValue);
                        }
                    }

                    if (progressCallback && row % 16 === 0) {
                        progressCallback(70 + (row / 256) * 25, 
                            `Built ${row}/256 rows, ${distributedCount.toLocaleString()}/${totalPairs.toLocaleString()} homophones`);
                    }
                }

                // Verification
                if (distributedCount !== totalPairs) {
                    throw new Error(`Distribution error: ${distributedCount} distributed vs ${totalPairs} total`);
                }

                this.initialized = true;
                this.metrics.initializationTime = performance.now() - startTime;

                return {
                    charactersUsed: characterCount,
                    totalHomophones: totalPairs,
                    homophonesPerCell: baseHomophonesPerCell,
                    extraHomophones: extraHomophones,
                    distributedCount: distributedCount,
                    verification: distributedCount === totalPairs ? "PASS" : "FAIL"
                };
            }

            generateCharacterSet(count) {
                // Professional approach: Use valid Chinese character ranges
                const ranges = [
                    [0x4E00, 0x9FFF],   // CJK Unified Ideographs
                    [0x3400, 0x4DBF],   // CJK Extension A
                    [0x20000, 0x2A6DF], // CJK Extension B
                ];

                let characters = '';
                let generated = 0;
                let rangeIndex = 0;

                while (generated < count && rangeIndex < ranges.length) {
                    const [start, end] = ranges[rangeIndex];
                    for (let codePoint = start; codePoint <= end && generated < count; codePoint++) {
                        try {
                            characters += String.fromCodePoint(codePoint);
                            generated++;
                        } catch (e) {
                            continue;
                        }
                    }
                    rangeIndex++;
                }

                // Fill remaining with mathematical symbols if needed
                while (generated < count) {
                    characters += String.fromCodePoint(0x2460 + (generated % 100));
                    generated++;
                }

                return characters.substring(0, count);
            }

            async cryptographicShuffle(array, key) {
                const result = [...array];
                const keyBuffer = new TextEncoder().encode(key);
                
                // Use Web Crypto API for professional shuffling
                for (let i = array.length - 1; i > 0; i--) {
                    // Create deterministic random index based on key and position
                    const data = new Uint8Array([...keyBuffer, ...new Uint8Array(new Uint32Array([i]).buffer)]);
                    const hash = await crypto.subtle.digest('SHA-256', data);
                    const hashArray = new Uint8Array(hash);
                    
                    const randomValue = new DataView(hashArray.buffer).getUint32(0);
                    const j = randomValue % (i + 1);
                    
                    [result[i], result[j]] = [result[j], result[i]];
                }
                
                return result;
            }

            encrypt(plaintext, useCryptoRandom = true) {
                if (!this.initialized) throw new Error("Cipher system not initialized");

                const startTime = performance.now();
                const encoder = new TextEncoder();
                const data = encoder.encode(plaintext);
                let ciphertext = '';

                for (let i = 0; i < data.length; i += 2) {
                    const byte1 = data[i];
                    const byte2 = (i + 1 < data.length) ? data[i + 1] : 0x00;
                    const value = (byte1 << 8) | byte2;

                    const homophones = this.sBox.get(value);
                    if (!homophones || homophones.length === 0) {
                        throw new Error(`No homophones available for value 0x${value.toString(16)}`);
                    }

                    // Professional random selection
                    let randomIndex;
                    if (useCryptoRandom) {
                        const cryptoArray = new Uint32Array(1);
                        crypto.getRandomValues(cryptoArray);
                        randomIndex = cryptoArray[0] % homophones.length;
                    } else {
                        randomIndex = (value + i) % homophones.length; // Deterministic for testing
                    }

                    ciphertext += homophones[randomIndex];
                }

                this.metrics.encryptionSpeed = data.length / ((performance.now() - startTime) / 1000);
                return ciphertext;
            }

            decrypt(ciphertext) {
                if (!this.initialized) throw new Error("Cipher system not initialized");
                if (ciphertext.length % 2 !== 0) throw new Error("Ciphertext length must be even");

                const startTime = performance.now();
                const byteArray = [];

                for (let i = 0; i < ciphertext.length; i += 2) {
                    const homophone = ciphertext.substring(i, i + 2);
                    const value = this.reverseMap.get(homophone);

                    if (value === undefined) {
                        throw new Error(`Unknown homophone sequence at position ${i}: ${homophone}`);
                    }

                    byteArray.push((value >> 8) & 0xFF);
                    byteArray.push(value & 0xFF);
                }

                // Remove padding carefully
                let finalLength = byteArray.length;
                while (finalLength > 0 && byteArray[finalLength - 1] === 0x00) {
                    finalLength--;
                }

                const result = new TextDecoder().decode(new Uint8Array(byteArray.slice(0, finalLength)));
                this.metrics.decryptionSpeed = ciphertext.length / ((performance.now() - startTime) / 1000);
                return result;
            }

            calculateEntropy(text) {
                const frequency = new Map();
                for (const char of text) {
                    frequency.set(char, (frequency.get(char) || 0) + 1);
                }

                let entropy = 0;
                const length = text.length;
                for (const count of frequency.values()) {
                    const probability = count / length;
                    entropy -= probability * Math.log2(probability);
                }

                this.metrics.entropy = entropy;
                return entropy;
            }
        }

        // Global system instance
        const cipherSystem = new ProfessionalChineseCipher();

        // UI Management
        function updateStatus(message, type = 'info') {
            const status = document.getElementById('systemStatus');
            status.textContent = `‚óè ${message}`;
            status.className = `status status-${type}`;
        }

        function updateProgress(percent, message = '') {
            document.getElementById('initProgress').style.width = percent + '%';
            if (message) updateStatus(message, 'info');
        }

        async function initializeCipherSystem() {
            const key = document.getElementById('encryptionKey').value;
            const characterCount = parseInt(document.getElementById('characterSet').value);

            if (!key) {
                updateStatus('Please enter an encryption key', 'error');
                return;
            }

            try {
                updateStatus('Initializing professional cipher system...', 'info');
                
                const results = await cipherSystem.initializeSystem(
                    key, 
                    characterCount,
                    updateProgress
                );

                // Update statistics
                document.getElementById('totalHomophones').textContent = results.totalHomophones.toLocaleString();
                document.getElementById('homophonesPerCell').textContent = `${results.homophonesPerCell}-${results.homophonesPerCell + 1}`;
                document.getElementById('characterCount').textContent = results.charactersUsed;

                updateStatus(`System ready! ${results.totalHomophones.toLocaleString()} homophones distributed across 65,536 S-Box cells`, 'success');
                
                updatePerformanceMetrics();
                
            } catch (error) {
                updateStatus(`Initialization failed: ${error.message}`, 'error');
                console.error('Initialization error:', error);
            }
        }

        function encryptMessage() {
            if (!cipherSystem.initialized) {
                updateStatus('Please initialize the cipher system first', 'error');
                return;
            }

            const plaintext = document.getElementById('plaintext').value;
            const useCryptoRandom = document.getElementById('randomnessMode').value === 'crypto';

            if (!plaintext) {
                updateStatus('Please enter text to encrypt', 'error');
                return;
            }

            try {
                updateStatus('Encrypting message...', 'info');
                const ciphertext = cipherSystem.encrypt(plaintext, useCryptoRandom);
                
                document.getElementById('ciphertextOutput').textContent = ciphertext;
                document.getElementById('ciphertextInput').value = ciphertext;
                
                const entropy = cipherSystem.calculateEntropy(ciphertext);
                updateStatus(`Encryption successful! Entropy: ${entropy.toFixed(2)} bits/character`, 'success');
                
                updatePerformanceMetrics();
                
            } catch (error) {
                updateStatus(`Encryption failed: ${error.message}`, 'error');
            }
        }

        function decryptMessage() {
            if (!cipherSystem.initialized) {
                updateStatus('Please initialize the cipher system first', 'error');
                return;
            }

            const ciphertext = document.getElementById('ciphertextInput').value;

            if (!ciphertext) {
                updateStatus('Please enter ciphertext to decrypt', 'error');
                return;
            }

            try {
                updateStatus('Decrypting message...', 'info');
                const plaintext = cipherSystem.decrypt(ciphertext);
                
                document.getElementById('decryptedOutput').textContent = plaintext;
                updateStatus('Decryption successful!', 'success');
                
                updatePerformanceMetrics();
                
            } catch (error) {
                updateStatus(`Decryption failed: ${error.message}`, 'error');
            }
        }

        function updatePerformanceMetrics() {
            const metrics = cipherSystem.metrics;
            document.getElementById('performanceMetrics').textContent = 
                `Initialization Time: ${metrics.initializationTime.toFixed(0)}ms\n` +
                `Encryption Speed: ${metrics.encryptionSpeed.toFixed(0)} bytes/sec\n` +
                `Decryption Speed: ${metrics.decryptionSpeed.toFixed(0)} chars/sec\n` +
                `Entropy: ${metrics.entropy.toFixed(2)} bits/character`;
        }

        function runDiagnostics() {
            if (!cipherSystem.initialized) {
                updateStatus('System not initialized', 'error');
                return;
            }

            // Test reversibility
            const testMessage = "Hello World 123! @#$%";
            try {
                const encrypted = cipherSystem.encrypt(testMessage, false); // Deterministic for testing
                const decrypted = cipherSystem.decrypt(encrypted);
                
                const success = testMessage === decrypted;
                updateStatus(`Diagnostics: ${success ? 'PASS' : 'FAIL'} - Reversibility test`, 
                           success ? 'success' : 'error');
                           
            } catch (error) {
                updateStatus(`Diagnostics failed: ${error.message}`, 'error');
            }
        }

        // Auto-initialize with default settings
        window.addEventListener('load', () => {
            updateStatus('Professional Chinese Homophonic Cipher System Ready', 'info');
        });
    </script>
</body>
</html>
